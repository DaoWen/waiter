#!/usr/bin/env python3

import argparse
import base64
import datetime
import http.server
import itertools
import json
import logging
import os
import random
import socketserver
import string
import sys
import threading
import time
import urllib.parse
import uuid
import zlib

def split2(string, delimiter, *options, default=None):
    """Split string with at least 2 results"""
    components = string.split(delimiter, *options)
    if len(components) < 2:
        components = (components + [default, default])[:2]
    return components

def run_after_ms(millis_delay, f, *args, **kwargs):
    """Asynchronousely execute function `f(*args, **kwargs)` after millis_delay."""
    threading.Timer(millis_delay / 1000.0, f, args, kwargs).start()

def request_info(method, headers, path, query_string):
    """Build request-info endpoint dict data JSON response."""
    info = { 'request-method': method, 'uri': path }
    if len(headers) > 0:
        info['headers'] = { k.lower(): v for k, v in headers.items() }
    if query_string is not None:
        info['query-string'] = query_string
    return json.dumps(info, sort_keys=True)

def terminate(source):
    """Forcefully terminate this server process."""
    logger.info('Killed by {}'.format(source))
    os._exit(1)

def check_auth(path, auth_string):
    """Validate user authentication credentials, with exceptions for excluded endpoints."""
    if _auth_handler is None:
        return True
    elif path in ['/bad-status', '/sleep', '/status']:
        return True
    else:
        return auth_string and _auth_handler(auth_string)

def random_string(chars, result_size):
    """Return a string of length `result_size` of random characters from `chars`."""
    return ''.join(random.choice(chars) for i in range(result_size))

ascii_bytes = ''.join(chr(x) for x in range(128))

lorem_ipsum = b'Lorem ipsum dolor sit amet, proin in nibh tellus penatibus, viverra nunc risus ligula proin ligula.'

default_chunk_size = 1000  # 1KB
max_response_size = 50000000  # 50MB
max_ws_response_size = 128000000  # 128MB

_auth_handler = None

_async_state_lock = threading.Lock()
_async_state = {}

_counter_lock = threading.Lock()
_pending_http_requests = 0
_total_http_requests = 0
_pending_ws_requests = 0
_total_ws_requests = 0

def make_default_response_headers(request_headers):
    return {'Connection': 'close',
            'Content-Type': 'text/plain',
            'x-cid': request_headers.get('x-cid') or str(uuid.uuid4())
            }

class Kitchen(http.server.BaseHTTPRequestHandler):
    def do_COPY(self):
        self.__handle_request('copy')

    def do_DELETE(self):
        self.__handle_request('delete')

    def do_GET(self):
        self.__handle_request('get')

    def do_HEAD(self):
        self.__handle_request('head')

    def do_MOVE(self):
        self.__handle_request('move')

    def do_PATCH(self):
        self.__handle_request('patch')

    def do_POST(self):
        self.__handle_request('post')

    def do_PUT(self):
        self.__handle_request('put')

    def __handle_request(self, method):
        global _pending_http_requests, _total_http_requests
        with _counter_lock:
            _pending_http_requests += 1
            _total_http_requests += 1

        # Defaults
        self.__async_req = None
        self.__chunked = False
        self.__chunk_size = default_chunk_size
        self.__cookies = {}
        self.__data_transform = None
        self.__excluded_headers = set()
        self.__exit_process = False
        self.__headers = make_default_response_headers(self.headers)
        self.__method = method
        self.__path = None
        self.__query = None
        self.__response_bytes = None
        self.__response_length = max_response_size
        self.__status = 200
        self.__truncated_length = max_response_size + 1

        # Process request parameters
        self.__process_path()
        self.__process_headers()

        # Handle async resource requests
        if self.__async_req is not None:
            if self.__async_req['type'] == 'create':
                self.__resource_async_create()
            elif self.__async_req['type'] == 'status':
                self.__resource_async_status()
            elif self.__async_req['type'] == 'result':
                self.__resource_async_result()

        # Optionally transform (e.g., compress) response bytes
        response_bytes = self.__response_bytes
        if self.__data_transform is not None:
            response_bytes = itertools.islice(response_bytes, self.__response_length)
            response_bytes = self.__data_transform(bytes(response_bytes))
            self.__response_length = len(response_bytes)

        # Handle no content / content length / chunking
        if self.__status == 204:
            response_bytes = None  # HTTP 204 No Content
        elif self.__chunked:
            self.__headers['Transfer-Encoding'] = 'chunked'
            if self.__chunk_size <= 0:
                self.__chunk_size = default_chunk_size
        else:
            self.__headers['Content-Length'] = self.__response_length

        # Send response headers
        self.protocol_version = 'HTTP/1.1'
        self.send_response(self.__status)
        for k, v in sorted(self.__cookies.items()):
            k = urllib.parse.quote_plus(k)
            v = urllib.parse.quote_plus(v)
            self.send_header('Set-Cookie', '{}={}'.format(k, v))
        for k, v in self.__headers.items():
            if k.lower() not in self.__excluded_headers:
                self.send_header(k, v)
        self.end_headers()

        if response_bytes is not None:

            # Handle response length and truncation from failures
            actual_response_length = min(self.__truncated_length, self.__response_length)
            response_bytes = itertools.islice(self.__response_bytes, actual_response_length)

            # Send response body
            bytes_written = 0
            while True:
                chunk = bytes(itertools.islice(response_bytes, self.__chunk_size))
                if len(chunk) == 0:
                    if self.__chunked:
                        self.wfile.write(b'0\r\n\r\n')
                    break
                else:
                    if self.__chunked:
                        chunk_header = '{:X}\r\n'.format(len(chunk))
                        self.wfile.write(chunk_header.encode('ascii'))
                    self.wfile.write(chunk)
                    bytes_written += len(chunk)
                    if bytes_written == self.__truncated_length:
                        break
                    if self.__chunked:
                        self.wfile.write(b'\r\n')
                    self.wfile.flush()

        # Optionally trigger a fatal server error (exit)
        if self.__exit_process:
            terminate('failure header')

        with _counter_lock:
            _pending_http_requests -= 1

    def __process_headers(self):
        assert self.__path is not None, 'Processes headers AFTER processing the request path.'

        # Asynchronous resource request id
        cancel_204 = self.headers.get('x-kitchen-204-on-async-cancel')
        if cancel_204 and self.__async_req:
            if cancel_204.lower() == 'false':
                self.__async_req['cancel_code'] = 200

        # Send "busy" response code
        act_busy = self.headers.get('x-kitchen-act-busy')
        if act_busy is not None:
            self.__status = 503

        # Asynchronous resource request id
        allow_cancel = self.headers.get('x-kitchen-allow-async-cancel')
        if allow_cancel and self.__async_req:
            if allow_cancel.lower() == 'false':
                self.__async_req['disallow_cancel'] = True

        # Chunk encoding
        if self.headers.get('x-kitchen-chunked') is not None:
            self.__chunked = True

        # Chunked encoding chunk size
        chunk_size = self.headers.get('x-kitchen-chunk-size')
        if chunk_size is not None:
            self.__chunk_size = int(chunk_size)
            self.__headers['Transfer-Encoding'] = 'chunked'

        # Cookies
        cookies = self.headers.get('x-kitchen-cookies')
        if cookies is not None:
            self.__cookies = dict(split2(item, '=', 1) for item in cookies.split(','))

        # Response delay
        delay_value = self.headers.get('x-kitchen-delay-ms')
        if delay_value:
            delay_ms = int(delay_value)
            if self.__async_req:
                self.__async_req['delay-ms'] = delay_ms
            else:
                time.sleep(delay_ms / 1000.0)

        # Kill this server (after some delay)
        die_value = self.headers.get('x-kitchen-die-after-ms')
        if die_value:
            termination_delay_ms = int(die_value)
            if termination_delay_ms >= 0:
                source = 'header after {} milliseconds'.format(termination_delay_ms)
                run_after_ms(termination_delay_ms, terminate, source)

        # Echo request body back to client
        if self.headers.get('x-kitchen-echo') is not None:
            post_bytes_count = int(self.headers.get('content-length', 0))
            self.__set_response(self.rfile.read(post_bytes_count))

        # Exclude some headers from response
        excluded_headers = self.headers.get('x-kitchen-exclude-headers')
        if excluded_headers:
            self.__excluded_headers = set(x.lower() for x in excluded_headers.split(','))

        # Response payload length
        truncated_size = self.headers.get('x-kitchen-fail-after')
        if truncated_size:
            self.__truncated_length = int(truncated_size)

        # Kill the whole server on failure
        if self.headers.get('x-kitchen-fail-by-terminating-jvm') is not None:
            self.__exit_process = True

        # Asynchronous resource request id
        req_id = self.headers.get('x-kitchen-request-id')
        if req_id and self.__async_req:
            self.__async_req['id'] = req_id

        # Response payload length
        response_size = self.headers.get('x-kitchen-response-size')
        if response_size:
            self.__response_length = int(response_size)

        # Response payload length
        async_expire_ms = self.headers.get('x-kitchen-store-async-response-ms')
        if async_expire_ms and self.__async_req:
            self.__async_req['expire-ms'] = int(async_expire_ms)

    def __process_path(self):
        path, query_string = split2(self.path, '?', 1)
        self.__path = path
        self.__query = query_string

        if not check_auth(path, self.headers.get('Authorization')):
            self.__status = 403
            self.__set_response(b'HTTP 403 - Forbidden\n')
            return

        if query_string:
            query_params = dict(split2(param, '=', 1) for param in query_string.split('&'))
        else:
            query_params = {}

        if path == '/async/request':
            self.__async_req = {
                    'delay-ms': 20000,
                    'expire-ms': 10000,
                    'type': 'create'
                    }

        if path == '/async/status':
            self.__async_req = {
                    'id': query_params.get('request-id'),
                    'type': 'status'
                    }

        if path == '/async/result':
            self.__async_req = {
                    'id': query_params.get('request-id'),
                    'type': 'result'
                    }

        elif path == '/bad-status':
            self.__status = int(query_params.get('status', 500))

        elif path == '/chunked':
            self.__chunked = True
            self.__set_response(itertools.cycle(lorem_ipsum), max_response_size)

        elif path == '/die':
            terminate('/die endpoint')

        elif path == '/environment':
            env = { k: v for k, v in os.environ.items() if 'password' not in k.lower() }
            self.__set_response(json.dumps(env, sort_keys=True).encode('utf-8'))
            self.__headers['Content-Type'] = 'application/json'

        elif path == '/gzip':
            self.__data_transform = zlib.compress
            self.__headers['Content-Encoding'] = 'gzip'
            self.__set_response(itertools.cycle(lorem_ipsum), max_response_size)

        elif path == '/kitchen-state':
            self.__state()

        elif path == '/request-info':
            self.__headers['Content-Type'] = 'application/json'
            info = request_info(self.__method, self.headers, path, query_string)
            self.__set_response(info.encode('utf-8'))

        elif path == '/sleep':
            self.__status = int(query_params.get('status', 200))
            sleep_ms = int(query_params.get('sleep-ms', 0))
            time.sleep(sleep_ms / 1000.0)

        elif path == '/unchunked':
            self.__set_response(itertools.cycle(lorem_ipsum), max_response_size)

        if self.__response_bytes is None:
            # Set default response
            self.__set_response(b'Hello World')

    def __resource_async_create(self):
        req_id = self.__async_req.get('id') or str(uuid.uuid4())
        delay_ms = self.__async_req['delay-ms']
        expire_ms = self.__async_req['expire-ms']
        now = datetime.datetime.now()
        expire_time = now + datetime.timedelta(milliseconds=expire_ms)
        req_meta_data = {
                'cid': self.__headers['x-cid'],
                'done': False,
                'expires': expire_time.isoformat(),
                'linger-ms': expire_ms,
                'processing-time': delay_ms,
                'received': now.isoformat()
                }

        with _async_state_lock:
            _async_state[req_id] = req_meta_data

        def async_complete_callback():
            with _async_state_lock:
                _async_state[req_id]['done'] = True
            run_after_ms(expire_ms, self.__resource_async_delete, req_id)

        run_after_ms(delay_ms, async_complete_callback)

        self.__status = 202
        self.__headers['x-kitchen-request-id'] = req_id
        self.__headers['Location'] = '/async/status?request-id={}'.format(req_id)
        self.__set_response('Accepted request {}'.format(req_id).encode('utf-8'))


    def __resource_async_delete(self, req_id):
        with _async_state_lock:
            if req_id in _async_state:
                del _async_state[req_id]

    def __resource_async_status(self):
        req_id = self.__async_req.get('id')
        if req_id is None:
            self.__status = 400
            self.__set_response(b'Missing request-id')
        else:
            with _async_state_lock:
                req_data = _async_state.get(req_id)
            if req_data is None:
                self.__status = 410
                msg = 'No data found for request-id {}'.format(req_id)
                self.__set_response(msg.encode('utf-8'))
            elif self.__method == 'delete':
                if self.__async_req.get('disallow_cancel'):
                    self.__status = 405
                    self.__set_response(b'Cancellation not supported!')
                else:
                    self.__resource_async_delete(req_id)
                    self.__status = self.__async_req.get('cancel_code', 204)
                    msg = 'Deleted request-id {}'.format(req_id)
                    self.__set_response(msg.encode('utf-8'))
            else:
                req_done = req_data and req_data['done']
                if req_done:
                    self.__status = 303
                    self.__headers['Location'] = '/async/result?request-id={}'.format(req_id)
                    msg = 'Processing complete for request-id {}'.format(req_id)
                    self.__set_response(msg.encode('utf-8'))
                else:
                    msg = 'Still processing request-id {}'.format(req_id)
                    self.__set_response(msg.encode('utf-8'))

    def __resource_async_result(self):
        req_id = self.__async_req.get('id')
        if req_id is None:
            self.__status = 400
            self.__set_response(b'Missing request-id')
        else:
            with _async_state_lock:
                req_data = _async_state.get(req_id, {})
            if not req_data:
                self.__status = 404
            response_json = json.dumps({'status': self.__status, **req_data})
            self.__headers['Content-Type'] = 'application/json'
            self.__set_response(response_json.encode('utf-8'))

    def __set_response(self, response_bytes, response_length=None):
        self.__response_bytes = response_bytes
        if response_length is None:
            self.__response_length = len(response_bytes)
        else:
            self.__response_length = response_length
        # Limit response length to the maximum supported size
        self.__response_length = min(max_response_size, self.__response_length)

    def __state(self):
        with _async_state_lock, _counter_lock:
            state = {
                'async-requests': _async_state,
                'pending-http-requests': _pending_http_requests,
                'pending-ws-requests': _pending_ws_requests,
                'total-http-requests': _total_http_requests,
                'total-ws-requests': _total_ws_requests
                }
        self.__headers['Content-Type'] = 'application/json'
        self.__set_response(json.dumps(state, sort_keys=True).encode('utf-8'))

class MultiThreadedServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
    """Serve each HTTP request on separate thread"""
    pass

class BasicAuthHandler():
    def __init__(self, username, password):
        b64_creds = base64.b64encode(':'.join([username, password]).encode('utf-8'))
        self.expected_auth = 'Basic {}'.format(b64_creds.decode())
    def __call__(self, auth_string):
        return auth_string == self.expected_auth

def start_http_server(args):
    """Start HTTP/1.1 server using command-line arguments."""
    logger.info('Starting HTTP server on port {}...'.format(args.port))
    kitchen = MultiThreadedServer(('', args.port), Kitchen)
    try:
        kitchen.serve_forever()
    except KeyboardInterrupt:
        kitchen.server_close()

def start_websockets_server(args):
    """Start WebSockets server using command-line arguments."""
    logger.info('Starting WebSockets server on port {}...'.format(args.port))

    import asyncio

    try:
        import websockets
        import websockets.compatibility
        import websockets.exceptions
    except ImportError:
        sys.exit('Missing websockets package.')

    binary_max_size = args.ws_max_binary_message_size
    text_max_size = args.ws_max_text_message_size
    msg_max_size = max(binary_max_size, text_max_size)

    class WSSP(websockets.server.WebSocketServerProtocol):
        @asyncio.coroutine
        def process_request(self, path, request_headers):
            if request_headers.get('Upgrade') != 'websocket':
                if path.startswith('/die'):
                    terminate('WebSocket /die endpoint')
                else:
                    msg = b'HTTP OK\n'
                    headers = make_default_response_headers(request_headers)
                    headers['Content-Length'] = len(msg)
                    return websockets.compatibility.OK, sorted(headers.items()), msg

    @asyncio.coroutine
    def handle_request(websocket, full_path):
        global _pending_ws_requests, _total_ws_requests

        path, query_string = split2(full_path, '?', 1)

        with _counter_lock:
            _pending_ws_requests += 1
            _total_ws_requests += 1
            connection_id = _total_ws_requests

        try:
            yield from websocket.send('Connected to kitchen')
            logger.info('[{}] Opened WebSocket connection'.format(connection_id))

            while True:
                logger.debug('Waiting for a message...')
                in_data = yield from websocket.recv()
                if len(in_data) > 1000:
                    logger.debug('[{}] Got data on websocket: <{}>'.format(connection_id, len(in_data)))
                else:
                    logger.debug('[{}] Got data on websocket: {}'.format(connection_id, in_data))

                if isinstance(in_data, bytes):
                    yield from websocket.send(in_data)
                    logger.debug('[{}] Sent echo bytes response'.format(connection_id))

                elif isinstance(in_data, str):
                    if in_data == 'request-info':
                        info = request_info('websocket', websocket.request_headers, path, query_string)
                        yield from websocket.send(info)
                        logger.debug('[{}] Sent request info json'.format(connection_id))

                    elif in_data.startswith('bytes-'):
                        response_size = int(in_data[6:])
                        logger.debug('[{}] Sending {} random bytes (max is {})'.format(connection_id, response_size, binary_max_size))

                        if response_size > binary_max_size:
                            error_msg = ('[{}] Requested binary payload of {} bytes exceeds maximum size {}.'
                                    .format(connection_id, response_size, binary_max_size))
                            logger.error(error_msg)
                            logger.debug(error_msg)
                            yield from websocket.close(1011, error_msg)
                            return

                        else:
                            msg = random_string(ascii_bytes, response_size)
                            yield from websocket.send(msg.encode('ascii'))
                            logger.debug('[{}] Sent random {} bytes'.format(connection_id, response_size))

                    elif in_data.startswith('chars-'):
                        response_size = int(in_data[6:])
                        logger.debug('[{}] Sending {} random chars (max is {})'.format(connection_id, response_size, text_max_size))

                        if response_size > text_max_size:
                            error_msg = ('[{}] Requested text payload of {} chars exceeds maximum size {}.'
                                    .format(connection_id, response_size, text_max_size))
                            logger.error(error_msg)
                            yield from websocket.close(1011, error_msg)
                            return

                        else:
                            msg = random_string(string.ascii_uppercase, response_size)
                            yield from websocket.send(msg)
                            logger.debug('[{}] Sent random {} char string'.format(connection_id, response_size))

                    else:
                        yield from websocket.send(in_data)
                        logger.debug('[{}] Sent echo string response'.format(connection_id))

                else:
                    error_msg = '[{}] Closing connection due to bad input of type {}.'.format(connection_id, type(in_data))
                    logger.error(error_msg)
                    yield from websocket.close(1003, error_msg)
                    return

        except websockets.exceptions.ConnectionClosed:
            logger.debug('[{}] Caught connection closed exception'.format(connection_id))

        finally:
            with _counter_lock:
                _pending_ws_requests -= 1
            logger.info('[{}] Closed WebSocket connection'.format(connection_id))

    start_server = websockets.serve(handle_request, '', args.port, create_protocol=WSSP, max_size=msg_max_size)

    asyncio.get_event_loop().run_until_complete(start_server)
    asyncio.get_event_loop().run_forever()

if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Mock HTTP Service')
    parser.add_argument('-p', '--port', metavar='PORT_NUMBER', type=int, default=8080, help='Server port number')
    parser.add_argument( '--ssl', action='store_true', help='Enable SSL mode')
    parser.add_argument('--start-up-sleep-ms', metavar='MILLIS', type=int, default=0, help='Delay before starting server')
    parser.add_argument('--websockets', action='store_true', help='Start server in WebSockets mode')
    parser.add_argument('--ws-max-binary-message-size', metavar='BYTES', type=int, default=max_ws_response_size,
            help='Maximum binary message response size (in bytes) allowed by the WebSocket server')
    parser.add_argument('--ws-max-text-message-size', metavar='CHARS', type=int, default=max_ws_response_size,
            help='Maximum text message response size (in characters) allowed by the WebSocket server')
    args = parser.parse_args()

    logging.basicConfig(filename='kitchen.log', level=logging.INFO)
    logger = logging.getLogger('kitchen')
    logger.setLevel(logging.DEBUG)

    username = os.environ.get('WAITER_USERNAME')
    password = os.environ.get('WAITER_PASSWORD')

    if username and password:
        logger.info('Basic Authentication Enabled')
        _auth_handler = BasicAuthHandler(username, password)

    if args.start_up_sleep_ms > 0:
        logger.info('Sleeping for {}ms...'.format(args.start_up_sleep_ms))
        time.sleep(args.start_up_sleep_ms / 1000.0)

    try:
        if args.websockets:
            start_websockets_server(args)
        else:
            start_http_server(args)

    finally:
        logger.info('Server is exiting.')
