#!/usr/bin/env python3

import argparse
import http.server
import itertools
import json
import os
import sys
import threading
import time
import socketserver
import urllib.parse
import zlib

def split2(string, delimiter, *options, default=None):
    """Split string with at least 2 results"""
    components = string.split(delimiter, *options)
    if len(components) < 2:
        components = (components + [default, default])[:2]
    return components

lorem_ipsum = b'Lorem ipsum dolor sit amet, proin in nibh tellus penatibus, viverra nunc risus ligula proin ligula.'

max_response_size = 50000000  # 50MB
default_chunk_size = 256

class JayJay(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.__handle_request('get')

    def do_POST(self):
        self.__handle_request('post')

    def do_PUT(self):
        self.__handle_request('put')

    def __handle_request(self, method):
        # Defaults
        self.__chunked = False
        self.__chunk_size = default_chunk_size
        self.__cookies = {}
        self.__data_transform = None
        self.__exit_process = False
        self.__headers = {'Connection': 'close', 'Content-Type': 'text/plain'}
        self.__method = method
        self.__query = None
        self.__response_bytes = None
        self.__response_length = max_response_size
        self.__status = 200
        self.__truncated_length = max_response_size + 1

        # Process request parameters
        self.__process_headers()
        self.__process_path()

        # Optionally transform response bytes
        if self.__data_transform is not None:
            self.__response_bytes = itertools.islice(self.__response_bytes, self.__response_length)
            self.__response_bytes = self.__data_transform(bytes(self.__response_bytes))
            self.__response_length = len(self.__response_bytes)

        # Handle content length / chunking
        if self.__chunked:
            self.__headers['Transfer-Encoding'] = 'chunked'
            if self.__chunk_size <= 0:
                self.__chunk_size = default_chunk_size
        else:
            self.__headers['Content-Length'] = self.__response_length

        # Send response headers
        self.protocol_version = 'HTTP/1.1'
        self.send_response(self.__status)
        for k, v in sorted(self.__cookies.items()):
            k = urllib.parse.quote_plus(k)
            v = urllib.parse.quote_plus(v)
            self.send_header('Set-Cookie', '{}={}'.format(k, v))
        for k, v in self.__headers.items():
            self.send_header(k, v)
        self.end_headers()

        # Handle response length and truncation from failures
        actual_response_length = min(self.__truncated_length, self.__response_length)
        response_bytes = itertools.islice(self.__response_bytes, actual_response_length)

        # Send response body
        bytes_written = 0
        while True:
            chunk = bytes(itertools.islice(response_bytes, self.__chunk_size))
            if len(chunk) == 0:
                if self.__chunked:
                    self.wfile.write(b'0\r\n\r\n')
                break
            else:
                if self.__chunked:
                    chunk_header = '{:X}\r\n'.format(len(chunk))
                    self.wfile.write(chunk_header.encode('ascii'))
                self.wfile.write(chunk)
                bytes_written += len(chunk)
                if bytes_written == self.__truncated_length:
                    break
                if self.__chunked:
                    self.wfile.write(b'\r\n')
                self.wfile.flush()

        # Optionally trigger a fatal server error (exit)
        if self.__exit_process:
            self.__terminate('failure header')

    def __process_headers(self):
        # Send "busy" response code
        act_busy = self.headers.get('x-kitchen-act-busy')
        if act_busy is not None:
            self.__status = 503

        # Chunk encoding
        if self.headers.get('x-kitchen-chunked') is not None:
            self.__chunked = True

        # Chunked encoding chunk size
        chunk_size = self.headers.get('x-kitchen-chunk-size')
        if chunk_size is not None:
            self.__chunk_size = int(chunk_size)
            self.__headers['Transfer-Encoding'] = 'chunked'

        # Cookies
        cookies = self.headers.get('x-kitchen-cookies')
        if cookies is not None:
            self.__cookies = dict(split2(item, '=', 1) for item in cookies.split(','))

        # Response delay
        delay_value = self.headers.get('x-kitchen-delay-ms')
        if delay_value:
            delay_ms = int(delay_value)
            time.sleep(delay_ms / 1000.0)

        # Kill this server (after some delay)
        die_value = self.headers.get('x-kitchen-die-after-ms')
        if die_value:
            termination_delay_ms = int(die_value)
            if termination_delay_ms >= 0:
                source = 'header after {} milliseconds'.format(termination_delay_ms)
                threading.Timer(termination_delay_ms / 1000.0, self.__terminate, source)

        # Echo request body back to client
        if self.headers.get('x-kitchen-echo') is not None:
            post_bytes_count = int(self.headers.get('content-length', 0))
            self.__response_bytes = self.rfile.read(post_bytes_count)
            self.__response_length = len(self.__response_bytes)

        # Kill the whole server on failure
        if self.headers.get('x-kitchen-fail-by-terminating-jvm') is not None:
            self.__exit_process = True

        # Response payload length
        response_size = self.headers.get('x-kitchen-response-size')
        if response_size:
            self.__response_length = int(response_size)

        # Response payload length
        truncated_size = self.headers.get('x-kitchen-fail-after')
        if truncated_size:
            self.__truncated_length = int(truncated_size)

    def __process_path(self):
        path, query_string = split2(self.path, '?', 1)

        if query_string:
            query_params = dict(split2(param, '=', 1) for param in query_string.split('&'))
        else:
            query_params = {}

        if path == '/bad-status':
            self.__status = int(query_params.get('status', 500))

        elif path == '/chunked':
            self.__chunked = True
            self.__response_bytes = itertools.cycle(lorem_ipsum)

        elif path == '/die':
            self.__terminate('/die endpoint')

        elif path == '/environment':
            env = { k: v for k, v in os.environ.items() if 'password' not in k.lower() }
            self.__set_response(json.dumps(env, sort_keys=True).encode('utf-8'))
            self.__headers['Content-Type'] = 'application/json'

        elif path == '/gzip':
            self.__data_transform = zlib.compress
            self.__headers['Content-Encoding'] = 'gzip'
            self.__response_bytes = itertools.cycle(lorem_ipsum)

        elif path == '/request-info':
            info = { 'request-method': self.__method, 'uri': path }
            if len(self.headers) > 0:
                info['headers'] = { k.lower(): v for k, v in self.headers.items() }
            if query_string is not None:
                info['query-string'] = query_string
            self.__set_response(json.dumps(info, sort_keys=True).encode('utf-8'))
            self.__headers['Content-Type'] = 'application/json'

        elif path == '/sleep':
            self.__status = int(query_params.get('status', 200))
            sleep_ms = int(query_params.get('sleep-ms', 0))
            time.sleep(sleep_ms / 1000.0)

        elif path == '/unchunked':
            self.__response_bytes = itertools.cycle(lorem_ipsum)

        if self.__response_bytes is None:
            # Set default response
            self.__set_response(b'Hello World')


    def __set_response(self, response_bytes, response_length=None):
        self.__response_bytes = response_bytes
        if response_length is None:
            self.__response_length = len(response_bytes)
        else:
            self.__response_length = response_length
        # Limit response length to the maximum supported size
        self.__response_length = min(max_response_size, self.__response_length)

    def __terminate(self, source):
        print('Killed by {}'.format(source), file=sys.stderr)
        os._exit(1)

class MultiThreadedServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
    """Serve each HTTP request on separate thread"""

if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Mock HTTP Service')
    parser.add_argument('-p', '--port', metavar='PORT_NUMBER', type=int, default=8080, help='Server port number')
    parser.add_argument('--start-up-sleep-ms', metavar='MILLIS', type=int, default=0, help='Delay before starting server')
    args = parser.parse_args()

    if args.start_up_sleep_ms > 0:
        print("Sleeping for {}ms...".format(args.start_up_sleep_ms))
        time.sleep(args.start_up_sleep_ms / 1000.0)

    print("Starting server on port {}...".format(args.port))

    jayjay = MultiThreadedServer(('', args.port), JayJay)

    try:
        jayjay.serve_forever()
    except KeyboardInterrupt:
        jayjay.server_close()
